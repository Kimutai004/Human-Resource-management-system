const path = require(`path`);
const {resolveModuleName} = require(`ts-pnp`);

function nothing() {
  // ¯\_(ツ)_/¯
}

function getModuleLocator(module) {
  const pnp = require(`pnpapi`);

  const moduleLocation = typeof module === `string`
    ? module
    : module.filename;

  if (!moduleLocation)
    throw new Error(`The specified module doesn't seem to exist on the filesystem`);

  const moduleLocator = pnp.findPackageLocator(moduleLocation);

  if (!moduleLocator)
    throw new Error(`the specified module doesn't seem to be part of the dependency tree`);

  return moduleLocator;
}

function getDependencyLocator(sourceLocator, name) {
  const pnp = require(`pnpapi`);

  const {packageDependencies} = pnp.getPackageInformation(sourceLocator);
  const reference = packageDependencies.get(name);

  return {name, reference};
}

function getSourceLocation(sourceLocator) {
  if (!sourceLocator)
    return null;

  const pnp = require(`pnpapi`);

  const sourceInformation = pnp.getPackageInformation(sourceLocator);

  if (!sourceInformation)
    throw new Error(`Couldn't find the package to use as resolution source`);

  if (!sourceInformation.packageLocation)
    throw new Error(`The package to use as resolution source seem to not have been installed - maybe it's a devDependency not installed in prod?`);

  return sourceInformation.packageLocation.replace(/\/?$/, `/`);
}

function makeResolver(sourceLocator, filter) {
  const sourceLocation = getSourceLocation(sourceLocator);

  return resolver => {
    const BACKWARD_PATH = /^\.\.([\\\/]|$)/;

    const resolvedHook = resolver.ensureHook(`resolve`);

    // Prevents the SymlinkPlugin from kicking in. We need the symlinks to be preserved because that's how we deal with peer dependencies ambiguities.
    resolver.